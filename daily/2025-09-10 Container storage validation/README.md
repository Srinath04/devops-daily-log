
# ðŸ“˜ Documentation â€“ 10 Sept 2025

## Scenario 1:  Debugging Nginx Pod Volume Mounts and Container Access

### Summary:

Worked on troubleshooting **Nginx pod volume mounts** and verified how log files (`app.log`) are mapped inside a container even when i notice its not explicitly mentioned in YAML.

---
## Background

- Objective was to understand how a container inside Kubernetes accesses specific files (e.g., `/usr/share/nginx/html/app.log`) when the **YAML manifest only specifies the parent directory** (`/usr/share/nginx/html`) as the mount path.
    
- Needed to confirm if Kubernetes automatically handles sub-files or if explicit path mapping is required.
    
- Hands-on validation was done by **exec-ing into the pod** and inspecting the volume mount paths from inside.
    
---
##  Work Done

### 1. YAML Review

- YAML was mounting the directory:
    
    `volumeMounts:   - name: html-volume     mountPath: /usr/share/nginx/html`
    
- But there was no explicit mention of `app.log`.
    
### 2. Key Question

 _How does the container know to pick `app.log` if only the directory is mounted?_

### 3. Pod Access and Debugging

- Executed into the running pod:
    
    `kubectl exec -it <nginx-pod> -- /bin/sh`
    
- Navigated to `/usr/share/nginx/html` to list files and confirm `app.log` presence.
    
### 4. Observation

- Since **Kubernetes mounts the entire directory**, any files under it (like `app.log`) automatically become available inside the container.
    
- It's not necessary to explicitly list sub-files in `volumeMounts` â€“ mounting the parent directory is sufficient.
    
- If `app.log` exists in the hostPath or PVC, it will reflect inside the container at the specified path.    

---
## Learnings

1. **VolumeMount behavior** â€“ when i mount a directory, Kubernetes brings the entire directory tree inside the container, not just the path itself.
    
2. **File visibility** â€“ any file created/modified in that directory (from either host or container) will sync both ways.
    
3. **Best Practice** â€“ if the requirement is only one file, i can use **subPath** in `volumeMounts` to avoid overwriting the entire directory. Example:
    
    `volumeMounts:   - name: html-volume     mountPath: /usr/share/nginx/html/app.log     subPath: app.log`
    
    This ensures only that file is mounted.    

---
## Scenario 2: Understanding Sidecar, InitContainer, and Co-located Containers

###  Background

- Explored the difference between **sidecar containers**, **initContainers**, and the broader concept of **co-located containers** inside a Kubernetes Pod.
    
- This is important for cka certification as well as real world workload design where multiple containers must share resources, lifecycle, or responsibilities.
    
### ðŸ”¹ Key Points

1. **InitContainer**
    
    - Runs **before main app containers**.
    - Used for **setup tasks** (e.g., fetching config, waiting for dependencies).
    - Executes sequentially and exits once done.
    
    `initContainers:   - name: init-myservice     image: busybox     command: ["sh", "-c", "echo Initializing... && sleep 5"]`
    
2. **Sidecar Container**
    
    - Runs **alongside the main container** for the lifetime of the Pod.
    - Common uses: logging agents, proxy servers, service mesh sidecars.
    - Example: Nginx serving logs generated by another container.
    
    `containers:   - name: app     image: myapp:latest   - name: sidecar-logger     image: busybox:1.36
    
3. **Co-located Container**
    
    - General term for **all containers inside a single Pod**.
    - They share **network, IPC, and storage volumes**.
    - Both **sidecars** and main app containers are examples of co-located containers.
        
###  Learnings

- **InitContainer â‰  Sidecar** â€“ they serve different purposes.
- A **Pod is a co-location boundary**, meaning any container inside it is co-located.

## ðŸ“Œ End of Day Summary

- Clarified the distinction between **InitContainer, Sidecar, and co-located containers** â€“ key conceptual area for CKA.
    
- Practically debugged **volume mount behavior** in an Nginx pod and learned when to use `subPath`.
    
- Reinforced the habit of **verifying with `kubectl exec`** rather than assuming manifest behaviour.
